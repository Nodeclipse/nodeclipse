{
  "source": "doc/api/util.markdown",
  "modules": [
    {
      "textRaw": "util",
      "name": "util",
      "stability": 5,
      "stabilityText": "Locked",
      "desc": "<p>These functions are in the module <code>&apos;util&apos;</code>. Use <code>require(&apos;util&apos;)</code> to access\nthem.\n\n\n</p>\n",
      "methods": [
        {
          "textRaw": "util.format()",
          "type": "method",
          "name": "format",
          "desc": "<p>Returns a formatted string using the first argument as a <code>printf</code>-like format.\n\n</p>\n<p>The first argument is a string that contains zero or more <em>placeholders</em>.\nEach placeholder is replaced with the converted value from its corresponding\nargument. Supported placeholders are:\n\n</p>\n<ul>\n<li><code>%s</code> - String.</li>\n<li><code>%d</code> - Number (both integer and float).</li>\n<li><code>%j</code> - JSON.</li>\n<li><code>%%</code> - single percent sign (<code>&apos;%&apos;</code>). This does not consume an argument.</li>\n</ul>\n<p>If the placeholder does not have a corresponding argument, the placeholder is\nnot replaced.\n\n</p>\n<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;); // &apos;foo:%s&apos;</code></pre>\n<p>If there are more arguments than placeholders, the extra arguments are\nconverted to strings with <code>util.inspect()</code> and these strings are concatenated,\ndelimited by a space.\n\n</p>\n<pre><code>util.format(&apos;%s:%s&apos;, &apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;); // &apos;foo:bar baz&apos;</code></pre>\n<p>If the first argument is not a format string then <code>util.format()</code> returns\na string that is the concatenation of all its arguments separated by spaces.\nEach argument is converted to a string with <code>util.inspect()</code>.\n\n</p>\n<pre><code>util.format(1, 2, 3); // &apos;1 2 3&apos;</code></pre>\n",
          "signatures": [
            {
              "params": []
            }
          ]
        },
        {
          "textRaw": "util.debug(string)",
          "type": "method",
          "name": "debug",
          "desc": "<p>A synchronous output function. Will block the process and\noutput <code>string</code> immediately to <code>stderr</code>.\n\n</p>\n<pre><code>require(&apos;util&apos;).debug(&apos;message on stderr&apos;);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.log(string)",
          "type": "method",
          "name": "log",
          "desc": "<p>Output with timestamp on <code>stdout</code>.\n\n</p>\n<pre><code>require(&apos;util&apos;).log(&apos;Timestamped message.&apos;);</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "string"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.inspect(object, [showHidden], [depth], [colors])",
          "type": "method",
          "name": "inspect",
          "desc": "<p>Return a string representation of <code>object</code>, which is useful for debugging.\n\n</p>\n<p>If <code>showHidden</code> is <code>true</code>, then the object&apos;s non-enumerable properties will be\nshown too. Defaults to <code>false</code>.\n\n</p>\n<p>If <code>depth</code> is provided, it tells <code>inspect</code> how many times to recurse while\nformatting the object. This is useful for inspecting large complicated objects.\n\n</p>\n<p>The default is to only recurse twice.  To make it recurse indefinitely, pass\nin <code>null</code> for <code>depth</code>.\n\n</p>\n<p>If <code>colors</code> is <code>true</code>, the output will be styled with ANSI color codes.\nDefaults to <code>false</code>.\n\n</p>\n<p>Example of inspecting all properties of the <code>util</code> object:\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nconsole.log(util.inspect(util, true, null));</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                },
                {
                  "name": "showHidden",
                  "optional": true
                },
                {
                  "name": "depth",
                  "optional": true
                },
                {
                  "name": "colors",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isArray(object)",
          "type": "method",
          "name": "isArray",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is an <code>Array</code>. <code>false</code> otherwise.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nutil.isArray([])\n  // true\nutil.isArray(new Array)\n  // true\nutil.isArray({})\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isRegExp(object)",
          "type": "method",
          "name": "isRegExp",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>RegExp</code>. <code>false</code> otherwise.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nutil.isRegExp(/some regexp/)\n  // true\nutil.isRegExp(new RegExp(&apos;another regexp&apos;))\n  // true\nutil.isRegExp({})\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isDate(object)",
          "type": "method",
          "name": "isDate",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is a <code>Date</code>. <code>false</code> otherwise.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nutil.isDate(new Date())\n  // true\nutil.isDate(Date())\n  // false (without &apos;new&apos; returns a String)\nutil.isDate({})\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.isError(object)",
          "type": "method",
          "name": "isError",
          "desc": "<p>Returns <code>true</code> if the given &quot;object&quot; is an <code>Error</code>. <code>false</code> otherwise.\n\n</p>\n<pre><code>var util = require(&apos;util&apos;);\n\nutil.isError(new Error())\n  // true\nutil.isError(new TypeError())\n  // true\nutil.isError({ name: &apos;Error&apos;, message: &apos;an error occurred&apos; })\n  // false</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "object"
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.pump(readableStream, writableStream, [callback])",
          "type": "method",
          "name": "pump",
          "desc": "<p>Experimental\n\n</p>\n<p>Read the data from <code>readableStream</code> and send it to the <code>writableStream</code>.\nWhen <code>writableStream.write(data)</code> returns <code>false</code> <code>readableStream</code> will be\npaused until the <code>drain</code> event occurs on the <code>writableStream</code>. <code>callback</code> gets\nan error as its only argument and is called when <code>writableStream</code> is closed or\nwhen an error occurs.\n\n\n</p>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "readableStream"
                },
                {
                  "name": "writableStream"
                },
                {
                  "name": "callback",
                  "optional": true
                }
              ]
            }
          ]
        },
        {
          "textRaw": "util.inherits(constructor, superConstructor)",
          "type": "method",
          "name": "inherits",
          "desc": "<p>Inherit the prototype methods from one\n<a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/constructor\">constructor</a>\ninto another.  The prototype of <code>constructor</code> will be set to a new\nobject created from <code>superConstructor</code>.\n\n</p>\n<p>As an additional convenience, <code>superConstructor</code> will be accessible\nthrough the <code>constructor.super_</code> property.\n\n</p>\n<pre><code>var util = require(&quot;util&quot;);\nvar events = require(&quot;events&quot;);\n\nfunction MyStream() {\n    events.EventEmitter.call(this);\n}\n\nutil.inherits(MyStream, events.EventEmitter);\n\nMyStream.prototype.write = function(data) {\n    this.emit(&quot;data&quot;, data);\n}\n\nvar stream = new MyStream();\n\nconsole.log(stream instanceof events.EventEmitter); // true\nconsole.log(MyStream.super_ === events.EventEmitter); // true\n\nstream.on(&quot;data&quot;, function(data) {\n    console.log(&apos;Received data: &quot;&apos; + data + &apos;&quot;&apos;);\n})\nstream.write(&quot;It works!&quot;); // Received data: &quot;It works!&quot;</code></pre>\n",
          "signatures": [
            {
              "params": [
                {
                  "name": "constructor"
                },
                {
                  "name": "superConstructor"
                }
              ]
            }
          ]
        }
      ],
      "type": "module",
      "displayName": "util"
    }
  ]
}
